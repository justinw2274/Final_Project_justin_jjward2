## Initial Brainstorming
I brainstormed three potential ideas for this Trading Journal project, with increasing complexity.

1.  **Basic Trade Logger:** A simple web app with a form to enter trade details (asset, entry/exit price, size) and a table to display them. It would calculate the profit or loss for each trade. This felt too simple for a final project.

2.  **Journal with Tagging:** Everything from the first idea, but with an added feature to "tag" each trade with a specific strategy (e.g., "Mean Reversion," "Breakout"). This would allow filtering the trade history by strategy, but the analysis would still be manual.

3.  **Advanced Performance Analyzer:** This version would include all of the above, plus an automated dashboard. It would calculate key performance indicators (KPIs) like win rate, average gain vs. loss, and profit factor. It would also feature data visualizations, like an equity curve chart, to provide a clear visual of account growth.

## Selection Rationale
I have selected **Idea #3, the Advanced Performance Analyzer**.

As someone with a strong interest in quantitative finance, a simple log is not enough. The true value of a trading journal is its ability to provide actionable insights. By automatically calculating KPIs and visualizing performance, this tool will help identify which strategies are working and which are not. This aligns perfectly with the goal of using data science to improve trading outcomes and is a suitably challenging scope for a final project.




#######################################
# Wireframe Notes
#######################################

I designed the wireframes to be clean, functional, and user-centric, focusing on providing the most critical information first.

*   **login.png:** A standard, minimalist login form to ensure a low-friction entry point for the user. No unnecessary distractions.

*   **dashboard.png:** The dashboard is designed with a "top-down" information hierarchy. The most important, at-a-glance metrics (KPIs) are at the very top. The equity curve is the main focus as it provides the quickest visual summary of performance over time. The detailed trade history is placed below, accessible when needed but not cluttering the primary view.

*   **core_feature.png (Trade Entry Form):** The form is designed for quick and efficient data entry, which is crucial for a journal to be used consistently. All essential fields are present, and the "Save Trade" button is prominent.

*   **error_state.png:** I created a simple 404 page with a clear message and a direct link back to the main dashboard. This provides a good user experience by preventing the user from getting stuck on a dead page.




#######################################
# Branching Strategy
#######################################

## Strategy Choice: Feature Branching

I have chosen a simple and effective **Feature Branching** model for this project. This is a standard workflow that is ideal for solo developers and teams alike.

## Branch Definitions

*   **`main`**: This is the primary branch of the repository. It will be kept clean and will always represent a stable, working version of the project. No direct commits will be made to `main`.

*   **`feature/<feature-name>`**: All new work will be done on a dedicated feature branch. These branches will be created from `main` for a single, specific task (e.g., `feature/user-authentication` or `feature/dashboard-chart`).

## Workflow

The development process will follow these steps:
1.  Create a new `feature/` branch from the `main` branch.
2.  Perform all work and make all commits for that feature on its branch.
3.  Once the feature is complete and tested, it will be merged back into the `main` branch.
4.  The feature branch can then be deleted.

## Rationale for this Choice

This strategy keeps the `main` branch clean, stable, and always in a deployable state. It isolates the development of new features, preventing unstable or in-progress code from breaking the main application. This makes it much easier to manage individual tasks, track changes, and debug issues without disrupting the entire project.

